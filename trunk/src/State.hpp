#ifndef MASTERMIND_FILTER_HPP
#define MASTERMIND_FILTER_HPP

#include <vector>
#include <bitset>
#include "Engine.hpp"

namespace Mastermind {

/**
 * Represents a constraint of the form <code>(guess,feedback)</code>.
 */
#if 0
struct Constraint
{
	Codeword guess;
	Feedback feedback;
};
#endif

/**
 * Represents a filter.
 *
 * A filter an (essentially unordered) set of constraints of the form
 * <code>(guess,feedback)</code>. When applied to a set of codewords, 
 * the filter selects the subset of elements that satisfy exactly those
 * constraints. We call this subset <i>generated</i> by the filter.
 *
 * A filter is called <i>contradictory</i> if its generated subset is
 * empty, i.e. no codeword could satisfy all the constraints.
 *
 * A constraint in a given filter is called <i>redundant</i> if the 
 * subset generated by the filter is the same with or without that
 * constraint. For example, the same constraint appearing twice is
 * clearly redundant. Also, consider the example:
 *   1234:0A0B
 *   3456:0A0B
 *   1256:0A0B
 * Any one of the constraints is redundant.
 *
 * A filter without redundant constraints is called an <i>irreductible</i>
 * filter. In the following we are only interested in irreductible filters.
 *
 * Two filters are <i>equal</i> if they contain the same constraints,
 * regardless of order. Note that this definition is NOT the same as 
 * defining equivalence on the generated subsets. For example, the 
 * filters
 *  f1 = (1234:0A0B, 3456:0A0B) and
 *  f2 = (1234:0A0B, 1256:0A0B)
 * are not equal by this definition, although they generate the same
 * subsets.
 *
 * Let @c S denote the whole set of codewords (according to some rules).
 * A few properties of a filter are shown below.
 *
 * 1. Not all subsets of @c S can be generated by a filter.
 *    (Todo: find an example, maybe {1234,5678}?).
 *    Those that can be generated are called <i>reachable</i>; those
 *    that cannot be obtained are called <i>unreachable</i>.
 * 2a. If two filters are equal, then the subsets generated from them
 *     are equal. (Obviously true)
 * 2b. If two subsets are different, and their generating filters (if
 *     exists) are different. (Equivalent condition to 2a.)
 * 3. If two filters are different, then the subsets generated from 
 *    them may or may not be equal. See the example above. For a 
 *    non-trivial example, consider the following simulated guessing
 *    process by different strategies:
 *
	 Secret: 7450
	 # simple    minmax    entropy   maxparts
	-------------------------------------------
	 1 0123:0A1B 0123:0A1B 0123:0A1B 0123:0A1B
	 2 1456:2A0B 1456:2A0B 1456:2A0B 1456:2A0B
	 3 1478:1A1B 2435:1A1B 7418:2A0B 2475:1A2B
	 4 1759:1A1B 0276:0A2B 0752:1A2B 0482:1A1B
	 5 1896:0A0B 7450:4A0B 7450:4A0B 7450:4A0B
	 6 2457:2A1B
	 7 7450:4A0B

Each column represents a filter that generates the single-element subset
<code>{7450}</code>. [Note: however, they are reductible!]

 *
// It could be roughly thought that a subset can be (not necesarily
// uniquely) represented by a filter.
//
// Two filters f1 and f2 are isomorphsm if there exists a permutation
// \pi=(\pi_c,\pi_p) of the colors and pegs such that
//   f1^\pi = f2.
// While it might be more stringent to define equivalence from the
// generated subset, the definition on the filter itself is easier
// to understand and works (well enough) for the purpose.
// 
// such that the filtered set are isomophsim . That is, let S be the
// set of all code words,
//
//   f1^\pi = f2. // and f1(S)^\pi = f2(S)
// 
// For example, (1234,1A1B) and (6789,1A1B) are equivalent, because
// we can use the permutation (not unique)
// (1 2 3 4 5 6 7 8 9 0)
// (6 7 8 9 0 1 2 3 4 5)
// Similarly, (1314:1A1B) and (5336:1A1B) are isomophsm because
// we can use the permutation (not unique) on colors
// (1 2 3 4 5 6 7 8 9 0)
// (3 2 5 6 3 4 7 8 9 0)
// and the following permutation on pegs
// (a b c d)
// (b a c d)
//
// In the first implementation, we only use a simple way to detect
// obvious isomorphism. Unobvious isomorphsim is not detected.
// A filter keeps track of the colors used in the constraints.
// It makes use of certain equivalence relations to reduce 
// the number of candidate guesses. It is aware of equivalence
// between guesses. And is able to give a set of "canonical" guess
// which are not isopmorphsm to each other.
// 
*/
#if 0
class Filter
{
	Engine &e;
	
	struct Constraint
	{
		Codeword guess;
		Feedback feedback;
		Constraint(const Codeword &g, const Feedback &f)
			: guess(g), feedback(f) { }
	};
	std::vector<Constraint> _constraints;

	/// Information about the guesses made so far. Used to prune the
	/// search space.
	struct Hints
	{
		/// Algorithm engine.
		Engine &e;

		/// Bit-mask of colors that have not been guessed so far.
		unsigned short fresh; // m_unguessed;

		/// Bit-mask of colors that are excluded from the possibilities.
		/// These colors are sure to be not present in the secret.
		unsigned short excluded; // m_impossible

		/// Bit-mask of colors guessed so far, excluding impossible digits.
		/// This member is not useful.
		unsigned short guessed; // m_guessed

		/// Initializes hints.
		Hints(Engine &engine)
			: e(engine), fresh(((unsigned short)1 << e.rules().colors()) - 1),
			excluded(0), guessed(0) { }

		/// Updates the hints with a new guess.
		void udpate(	const Codeword &guess, CodewordConstRange possibilities)
		{
			unsigned short allmask = ((unsigned short)1 << e.rules().colors()) - 1;
			fresh &= ~e.getDigitMask(guess);
			excluded = allmask & ~e.color_mask(possibilities);
			guessed = allmask & ~fresh & ~excluded;
		}
	};

public:

	Filter(Engine &engine) : e(engine)
	{
	}

	void add_constraint(
		const Codeword &guess, 
		Feedback feedback,
		CodewordConstRange remaining)
	{
		_constraints.push_back(Constraint(guess, feedback));
	}
};
#endif

/// Returns a subset of the codewords consisting of elements satisfy
/// the given filter.
// not used
//CodewordList match(CodewordConstRange codewords, const Filter &filter);

/**
 * Represents a state of the game. 
 *
 * Conceptually, a <i>state</i> of the game in an intermediate status
 * of the guessing process. A state is uniquely defined by a filter. 
 * However, the @c State structure contains some more book-keeping
 * members.
 */
struct State
{
	/// Set of remaining possible secrets given the feedbacks so far.
	/// Since this is a pair of iterators, the actual elements must
	/// be allocated separately.
	CodewordRange possibilities;

	/// Bit-mask of colors that have not been guessed so far.
	ColorMask fresh_colors;

	/// Bit-mask of colors that are excluded from the possibilities.
	/// These colors are sure to be not present in the secret.
	ColorMask excluded_colors;

	/// Initializes the state at the beginning of a game.
	State(Engine &e, CodewordRange all)
		: possibilities(all),
		fresh_colors((1 << e.rules().colors()) - 1), 
		excluded_colors(0) { }
	
	/// Updates the status.
	void udpate(	Engine &e, const Codeword &guess, CodewordRange remaining)
	{
		ColorMask allmask((1 << e.rules().colors()) - 1);
		fresh_colors &= ~ e.colorMask(guess);
		excluded_colors = allmask & ~ e.colorMask(remaining);
		possibilities = remaining;
	}

};


} // namespace Mastermind

#endif // MASTERMIND_FILTER_HPP
